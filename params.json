{"name":"Dystruct","tagline":"Dystruct makes dynamical creation of c structures easy","body":"Dystruct\r\n========\r\n\r\nAbstract\r\n--------\r\nDystruct is a little C-Library that lets you easily build your own\r\nC-Structures at runtime.\r\n\r\nIf you, for example, don't know which kinds of structures you have to pass to a\r\ndynamically called function (with libffi), you'll have to build them on the heap at runtime. This\r\nlibrary does just that while taking care of the correct alignment requirements of the \r\nmembers.\r\n\r\nUse case\r\n--------\r\nAs an use case example, consider the following code:\r\n\r\n    struct flat {\r\n        int a;\r\n        double b;\r\n        char c;\r\n    };\r\n    \r\n    [...]\r\n    \r\n    int do_sth(void){\r\n        struct flat *s = malloc(sizeof(struct flat));\r\n        s->a = 42;\r\n        s->b = 424242.424242\r\n        s->c = '*';\r\n        \r\n        return 0;\r\n    }\r\n\r\nThe structure s pointing to now lays on the heap and\r\nlooks like this:\r\n\r\n    Offset: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 \r\n           -+-----------+-----------+-----------------------+-\r\n           -|    42     |  padding  |    424242.424242      |-\r\n           -+-----------+-----------+-----------------------+-\r\n    Offset: 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\r\n           -+--+--------+-----------+\r\n           -|* |     padding        |\r\n           -+--+--------+-----------+\r\n\r\nAs you can see, the cells 4 to 7 contain meaningless bytes filling\r\nup the space between the member \"a\" and \"b\" of the recently defined structure \"flat\".\r\nThis is because the primitive type double has an alignment requirement\r\nof 8, meaning that a double value can only start at an offset\r\nwhich is a multiple of 8. The reason for this behaviour is very simple:\r\nPerformance! \r\n\r\nIf the wordsize of an architecture is, for example, 8 bytes, you wouldn't\r\nwant the value of a double type begin at offset 7 and end at 15, because\r\nthis would force the processor to load two words (each one 8 bytes big) into some\r\nworking registers. However, if all double values would be properly aligned,\r\nevery access to them could be done in just one cpu cycle.\r\n[see also](http://en.wikipedia.org/wiki/Data_structure_alignment)\r\n\r\nOk, now I know some of the internal mechanisms of data structure alignment. But what\r\ndo I need your library for?\r\n\r\nA very good question!\r\n\r\nConsider the following scenario: \r\nYou are building an interpreter for a programming\r\nlanguage that reads commands from the console and executes them as the user\r\ntypes enter. (Python is such a programming language for example). \r\nNow you want\r\nthe users of your interpreter to be able to use native C-Functions from within the language. \r\nThis is very possible and there is even a library that\r\nenables you to load and call arbitrary functions at runtime, without compiling and linking\r\nagainst libraries which contain them. (libffi provides such functionality)\r\nWhile this would be sufficient for functions taking only values of primitive types, \r\nyou, the programmer of the interpreter, would run into some severe problems when it\r\ncomes to functions taking merely a pointer to a structure laying on the heap.\r\nWhat do you do? You can't use C-Constructs like\r\n\r\n    strcut foo *f = malloc(...);\r\n    call_func(funcpointer, f);\r\n    \r\nbecause you don't have access to the structure definition and thus cannot\r\nrely on the compiler to do the things just right.\r\n\r\nThis is the point when it comes to this little library.\r\nWith it, the code above could be rewritten as follows:\r\n\r\n    uint32_t i1 = 42;\r\n    double d = 424242.424242;\r\n    uint8_t c1 = '*'\r\n\r\n    struct dstru_struct *ds1;\r\n    \r\n    dstru_add_member(DYN_S_UINT32, (void *) &i1, ds1);\r\n    dstru_add_member(DYN_S_DOUBLE, (void *) &d, ds1);\r\n    dstru_add_member(DYN_S_UINT8, (void *) &c1, ds1);\r\n    dstru_finalize(ds1) == 0;\r\n    \r\nds1 contains a member named \"buffer\", which is just a memory field.\r\nThis field now contains the exact same as the initialized \r\nstructure s in our first example including both padding byte sections.\r\n\r\nConfiguration\r\n-------------\r\nThe configure script provides the following additional\r\ncommand line options.\r\n\r\n* --enable-uint8-align=[integer] \r\n* --enable-uint16-align=[integer]\r\n* --enable-uint32-align=[integer]\r\n* --enable-uint64-align=[integer]\r\n* --enable-double-align=[integer]\r\n* --enable-float-align=[integer] \r\n* --enable-ptr-align=[integer]\r\n\r\nWith these options you can adjust the platform\r\nspecific alignment requirements for the host you'll be using\r\nthe library. Notice that you should only use powers of two\r\nas values for [integer]!\r\n\r\nInstallation\r\n------------\r\nJust use these commands:\r\n\r\n    $ ./configure [option=value] ...\r\n    $ make && make check\r\n    $ make install\r\n\r\nBuild system\r\n============\r\n\r\nDevelopment\r\n-----------\r\nAfter a fresh checkout of the repository, just execute the following command:\r\n\r\n    $ autoreconf --install\r\n\r\nThis will prepare the build system for your usage.\r\n\r\nSilent make rules\r\n-----------------\r\nIf you rather appreciate silent (or more silent)\r\nbuild processes, you can run the configure script \r\nas follows:\r\n\r\n    $ ./configure --enable-silent-rules\r\n\r\nWhile this does not completely silence the build, most of the commands executed by make rules\r\nwon't be shown anymore. Make will still output cd messages, though.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}